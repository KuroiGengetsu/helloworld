# 指向二维数组的指针

## 什么是数组

```C
int a[10];
int b[6][10];
```

上面定义了两个数组, a是一维数组, b是二维数组

### 一维数组

`int a[10]` // 假设之后给所有元素都赋了初值

首先, `a == &a[0]` 为真

定义了一个10元素的数组, 里面有10个 `int` 类型的变量, 数组名 `a` 是 **指向int型变量的常量指针**, 也就是说, 数组名其实就是 `const int *a = &第一个元素`, 与普通的指针不同的是 `sizeof(a)` 是数组的总字节数, a是一个常量指针,  且指向数组中第一个 int元素, 等同于 `&a[0]`, 所以 `*a`就代表第一个元素的值, 也就相当于 `a[0]`, 而 `a+1` 就代表 **指向第二个元素的常量指针**, 等同于 `&a[1]`, *(a+1)间接访问了 **第二个元素的值**, 相当于 `a[1]`

定义其他的指针指向这个一维数组, 就用下面的方法:
```C
int *one_dev = a;  // 定义一个指向一维数组的指针
```

因为上一段说了, `a` 就是一个指向int类型的常量指针, 所以 `a+1` 就代表 **指向第二个int元素的常量指针**, 这是因为指针的加减操作是以地址为单位加减的, 而不是数学意义上的 +1, 因为这个指针是 int 类型, 所以 +1 移动了 `1 * sizeof(int)` 个单位, 也就是指向了下一个元素的地址。 如果使用 **间接访问运算符** `*` , 也就是 `*a` , 其实就是第一个元素的值, 当然, `*a` 等同于 `*(a + 0)`, 也就是 a 移动了 0 个单位再间接访问, 还是相当于 `*a`。

再来看下一个:
`*(a + 1)` 就是 a 先移动了 `1 * sizeof(int)` 个单位, 指向了第二个int类型的元素, 这时候使用 **间访运算符** `*` 就是求得这个地址所储存的值, 也就是第二个元素的值。

### 二维数组

`int b[6][10]`  // 假设之后所有元素都赋了初值

首先, `b == &b[0]` 为真

这是一个二维数组, 一共有60个元素, 实际上是由6个10元素的一维数组组成, 而存放这六个数组名的就是 `数组名b` 这个指针数组, `b` 是 **指向数组的常量指针**, 即它指向的是指针, 之所以说是常量, 代表它所指向的地址不能改变, 但是那个地址的值是否可以改变, 就要看这个地址的变量是否 有 `const` 修饰符修饰, 由于它指向的是数组名, 所以还是常量指针, 所以这个数组的地址是无法改变的, 即数组名都是被const修饰的指针, 当然你是看不到哪里写了 const, 这是因为数组可以用下标来访问, 但是这些下标实际上都是对指针的操作, 你也可以用指针的形式访问他们。 但是你可以对 b[0][0] 进行赋值, 这是因为最内层的数组存放的是int型的变量, 没有被 const 修饰, 所以你可以进行赋值。

二维数组的存储空间是连续的, 首先从 **第一个数组的第一个元素到末尾的元素** , 接着是 **第二个数组的第一个元素** 到 **第二个数组的末尾元素** , 然后依次链接下去, 是连续的。数组名 `b` 指向第一个数组的数组名, 其存放的是第一个数组名的地址, 而第一个数组的数组名又是一个指向int类型的常量指针, 所以 `b` 是指向常量指针的常量指针。

如果要定义其他的指针指向二维数组的指针, 那么就应该如下:

```C
int (*two_dev)[10] = b;
```

其中中的 10 是必须指定的, 并且与b保持一致, 否则编译器会报错。

这里从头说起

首先, b 是个二维数组名, 它是指向数组的常量指针, 指向的是第一个数组的地址, 其实就是指向 **第一个数组的数组名**, 而第一个数组名是一个指向int型变量的常量指针, 因此, b 是一个 `指向常量指针的常量指针`, 这时候对 b 使用 间访运算符 `*`, 那么将会得到第一个数组的数组名。 为什么？ 因为b 存放的是第一个数组名的地址, 而间访运算符求得了这个地址的值, 也就是第一个数组名, 也就是常量指针, (注意不要将 `存放该指针的地址` 与 `该指针指向的地址` 搞混了), 因此 `*b` 就是第一个数组名, 等同于 `*(b + 1)`, 如果还不明白的话, 就尝试接收这样的说法: 这个二维数组是由六个 int 类型的数组构成, 而存放这六个数组名的数组是一个 `指针数组`, 即你可以将 b 看作是一个存放指针的数组, 而这些指针本身又指向了一个int型的数组。 C的数组就是由这样的关系组织起来的, 多维数组其实就是 `指针数组的嵌套`。

对这些概念稍微理解后, 来看下面这一堆分析:

| 指针表达式 | 说明 | 对应数组的下标表示 |
| :---: | :---- | :----: |
| `b` | 第一个数组名的地址 | 等同于 `&b[0]` |
| `b+1` | 第二个数组名的地址 | `&b[1]` |
| `*b` 或 `*(b+0)` | 第一个数组名, 也就是第一行第一个元素的地址 | `b[0]` 或 `&b[0][0]` |
| `*(b+1)` | 第二个数组名, 也就是第二行第一个元素的地址 | `b[1]` 或 `&b[1][0]` |
| `*(b+1) + 3` | 第二个数组名向右移动了3个单位(3 个 `sizeof(int)`) , 也就是第二行第四个元素的地址 | `b[1] + 3` 或 `&b[1][3]` |
| `*(*b)` | 第一行第一个元素的值 | `b[0][0]` |
| `*(*(b+1))` | 第二行第一个元素的值 | `b[1][0]` |
| `*(*(b+1) + 3)` | 第二行第四格元素的值 | `b[1][3]` |

接下来还有一中特殊的情况, 那就是:
`*b + 10*4 + 7` 所代表的是 第一个元素的数组名(第一行第一个元素的地址) `向右` 移动了 `10*4 + 7` 个单位, 也就是 `sizeof(int) * (10*4+7)`, 这里要注意, 第一个数组只有10个元素, 而 `10*4+7` 已经超过了 10 个, 这样难道不算越界吗?

当然不是, 上边提到过, 二维数组或更高维数组的元素地址都是连在一起的, 第一个数组一完马上就是第二个数组的元素的地址, 所以相当于一直在向右移动。

那么移动了多少呢? 
因为 10 * 4 是 40 , 也就是 40 个 sizeof(int), 所以指针目前停在第五个数组中, 因为从第一个数组移动了4个数组嘛。 接下来又移动了 7 个单位, 所以现在指向的是 `第五行第8个元素`。 也就是这个表达式等同于 `&b[4][7]`。

如果继续对它使用 **间访运算符** 的话, 那么就是 `b[4][7]` 的值了。但是这样是很危险的, 因为当给定的不是具体的数值而是变量, 那么不知道什么时候就指向了这个数组以外的地方, 如果使用 **间接访问运算符** 的话将会造成违法访问, 是很危险的, 不过大多数编译器会在违法访问时就终止程序, 但这也就给写程序的人造成了负担, 因为一般情况下不知道是什么原因终止了程序, 大多是都是由于空指针或违法访问造成的, 因为数组本来也和指针类似, 所以在这方面也会很头疼。

## 接下来讲述一个题目：

12. 设有语句 `int a[2][3]`, 下面哪一种表示 **不能** 表示元素 `a[i][j]`? (  `C`  )

* A. `*(a[i] + j)`
* B. `*(*(a + i) + j)`
* C. `*(a + i*3 + j)`
* D. `*(*a + i*3 + j)`

解析:

* A. 首先 `a[i]` 就是 `*(a + i)`, 代表第 i+1 行的数组, 也就是 第 i+1 行第一个元素的地址, `+ j` 就是向右移动 j 个单位, 所以是 `&a[i][j]`, 接下来再使用间访运算符 `*` 就获得了 `a[i][j]` 的值

* B. `a + i` 表示第 i+1 行的数组的地址, 也就是 `&a[i]`, 接下来使用 间访运算符 `*`, 那么就是 `*(a + i)` , 得到的是第 i+1 行的数组名, 也就是 `a[i]`; 接下来 `*(a + i) + j` 又向右移动了 j 个单位(sizeof(int)), 也就是 `a[i] + j`; 最后, 使用间访运算符 `*` , 即 `*(*(a + i) + j)` 获得了 `a[i][j]`

* C. `a` 是指向数组名的指针, 它的值是 `a[0]` 的地址, 也就是 `&a[0]`, 接下来 `a + i*3 + j` 是向下移动了 `i*3 + j` 行, 也就是说, 它只移动行数, 所以它指向的永远是对应行数的数组的第一个元素, 所以不可能是第 j + 1 个; 另外, 如果i 大于0 或 j 大于1, 那么就会越界, 又因为使用了 间访运算符, 所以会造成非法访问, 于是程序终止。 因此 C选项 错误。

* D. `*a` 代表 `a[0]`, `*a + i*3 + j` 表示向右移动了 `i*3 + j` 个单位, 又因为二维数组的最后一个下标是3, 因此移动了 `i 行 j 个元素`, 所以指向的就是 a[i][j], 这时使用 间访运算符 就获得了 a[i][j].
